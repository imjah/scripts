#!/bin/python

from argparse import ArgumentParser
from datetime import datetime
from json import JSONDecodeError
import asyncio
import json
import os
import signal
import sys
import threading
import time
from websockets import InvalidURI, InvalidHandshake, ConnectionClosed
import requests
import websockets
import yaml

class Channel:
    def __init__(self, id, config):
        self.id        = id
        self.fetched   = False
        self.timeout   = config['timeout']
        self.separator = config['separator']

    def fetch(self):
        for url in self.urls:
            try:
                self._fetch(url)
                self.fetched = True

                return
            except (KeyError, requests.RequestException):
                continue
            except BrokenPipeError:
                devnull = os.open(os.devnull, os.O_WRONLY)
                os.dup2(devnull, sys.stdout.fileno())
                sys.exit(1)

    def _date_to_clock(self, date: str) -> str:
        date = datetime.strptime(date, '%Y-%m-%dT%H:%M:%S%z')
        diff = datetime.now(date.tzinfo) - date

        return time.strftime('%H:%M:%S', time.gmtime(diff.total_seconds()))

class TT(Channel):
    def __init__(self, id, config):
        super().__init__(id, config)

        self.urls = config['safetwitch']

    def _fetch(self, url):
        channel = requests.get(f'{url}/api/users/{self.id}', timeout=self.timeout).json()['data']

        if channel['isLive']:
            print(
                self.separator.join([
                    channel['username'],
                    channel['stream']['title'],
                    channel['stream']['topic'],
                    str(channel['stream']['viewers']),
                    self._date_to_clock(channel['stream']['startedAt'].replace('Z', '+00:00')),
                    'https://twitch.tv/' + self.id
            ]), flush=True)

class YT(Channel):
    def __init__(self, id, config):
        super().__init__(id, config)

        self.urls = config['piped']

    def _fetch(self, url):
        videos = requests.get(f'{url}/channels/tabs?data={{"id":"{self.id}","contentFilters":["livestreams"]}}', timeout=self.timeout).json()['content']

        for video in videos:
            if video['duration'] == -1:
                stream = requests.get(f'{url}/streams/{video["url"][9:]}', timeout=self.timeout).json()

                print(
                    self.separator.join([
                        stream['uploader'],
                        stream['title'],
                        stream['category'],
                        str(stream['views']),
                        self._date_to_clock(stream['uploadDate']),
                        'https://youtube.com' + video['url']
                ]), flush=True)

class Channels:
    def __init__(self, config):
        self.channels = [TT(id, config) for id in config['twitch']] \
                      + [YT(id, config) for id in config['youtube']]

    def fetch(self):
        threads = [threading.Thread(target=c.fetch, daemon=True) for c in self.channels]

        for thread in threads:
            thread.start()

        for thread in threads:
            thread.join()

    def unfetched(self) -> list:
        return [channel.id for channel in self.channels if not channel.fetched]

class Chat:
    def __init__(self, id: str, config: dict):
        self.id         = id.split('/')[-1]
        self.uri        = [u.replace('http', 'ws') for u in config['safetwitch']]
        self.correction = config['chat-nick-correction']
        self.color_mod  = config['chat-badge-color-mod']
        self.color_vip  = config['chat-badge-color-vip']
        self.color_sub  = config['chat-badge-color-sub']

    async def listen(self):
        for uri in self.uri:
            try:
                async with websockets.connect(uri) as websocket:
                    await websocket.send(f'JOIN {self.id}')

                    async for message in websocket:
                        self.print(message)
            except OSError:
                print(f'warning: Instance "{uri}" not responding')
            except (InvalidURI, InvalidHandshake, ConnectionClosed) as e:
                exit(f'error: {e}')

        exit('error: No instance available')

    def print(self, message: str):
        try:
            m = json.loads(message)

            match m['type']:
                case 'PRIVMSG':
                    b = self._get_badges(m)

                    print('{}{}{} {} {}'.format(
                        self._paint(b[0], self.color_mod),
                        self._paint(b[1], self.color_vip),
                        self._paint(b[2], self.color_sub),
                        self._paint(f'<{m["username"]}>', self._hex_to_rgb(m['tags']['color'])),
                        m["message"].strip()
                    ))
                case 'CLEARCHAT':
                    try:
                        print(f'{m["message"].strip()} got a timeout for {m["tags"]["@ban-duration"]}s')
                    except KeyError:
                        print(f'{m["message"].strip()} has been banned')
                case _:
                    print(m['message'].strip())
        except (KeyError, JSONDecodeError):
            if message == 'OK':
                print('Connected to the chat room')
            else:
                print(message)

    def _get_badges(self, msg: dict) -> str:
        b = ''

        for tag in ['mod', 'vip', 'subscriber']:
            try:
                b += tag[0] if msg['tags'][tag] == '1' else '-'
            except KeyError:
                b += '-'

        return b.upper()

    def _hex_to_rgb(self, color_hex: str) -> str:
        """#010101 -> 1;1;1"""

        try:
            r = min(int(color_hex[1:3], 16) + self.correction, 255)
            g = min(int(color_hex[3:5], 16) + self.correction, 255)
            b = min(int(color_hex[5:7], 16) + self.correction, 255)
        except ValueError:
            return ';;'

        return f'{r};{g};{b}'

    def _paint(self, text: str, color_rgb: str) -> str:
        return f'\033[38;2;{color_rgb}m{text}\033[0m'

def get_config() -> dict:
    config_dir = os.environ.get('XDG_CONFIG_HOME', os.environ.get('HOME') + '/.config')

    with open(config_dir + '/ttv/config.yml') as f:
        return {
            **{
                'piped': ['https://pipedapi.kavin.rocks'],
                'safetwitch': ['https://stbackend.drgns.space'],
                'twitch': [],
                'youtube': [],
                'timeout': 5,
                'separator': ';',
                'chat-nick-correction': 0,
                'chat-badge-color-mod': '104;157;106',
                'chat-badge-color-vip': '177;98;134',
                'chat-badge-color-sub': '69;133;136'
            },
            **yaml.safe_load(f)
        }

async def main(args: ArgumentParser):
    signal.signal(signal.SIGINT, lambda s, f: sys.exit(1))
    config = get_config()

    if args.chat:
        await Chat(args.chat, config).listen()

        return

    channels = Channels(config)
    channels.fetch()

    if unfeched := channels.unfetched():
        sys.exit(f'error: Cannot fetch channel/s: {", ".join(unfeched)}')

if __name__ == '__main__':
    parser = ArgumentParser(
        prog='ttv',
        description='Feed for Twitch and YouTube livestreams'
    )

    parser.add_argument('-c', '--chat', help='Show chat for given channel id')

    try:
        asyncio.run(
            main(parser.parse_args())
        )
    except FileNotFoundError:
        sys.exit('error: Config not found')
    except yaml.YAMLError as e:
        sys.exit('error: Config syntax: ' + str(e))
    except KeyboardInterrupt:
        print()
